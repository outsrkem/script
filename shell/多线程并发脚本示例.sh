#!/bin/bash
# -----------------------------
workspace=$(cd `dirname $0`; pwd)
cd $workspace

# $$表示当前执行文件的PID
tempfifo=$$.fifo

# 进程数目,按需设置
processesNum=10

[ ! -d logs ] && mkdir logs

# 运行开始时间
echo `date +%Y-%m-%d\ %H:%M:%S` >> logs/data.log
# -----------------------------
# -----------------------------
# 表示在脚本运行过程中，如果接收到Ctrl+C中断命令，则关闭文件描述符1000的读写，并正常退出
# exec 1000>&-;表示关闭文件描述符1000的写
# exec 1000<&-;表示关闭文件描述符1000的读
# trap是捕获中断命令
trap "exec 1000>&-;exec 1000<&-;exit 0" 2

# 创建一个管道文件
mkfifo $tempfifo

# 将文件描述符1000与FIFO进行绑定，<读的绑定，>写的绑定，<>则标识对文件描述符1000的所有操作等同于对管道文件$tempfifo的操作
# 管道的一个重要特性，就是读写必须同时存在，缺失某一个操作，另一个操作就是滞留，而第28行的绑定文件描述符（读、写绑定）正好解决了这个问题
exec 1000<>$tempfifo
rm -rf $tempfifo

# 对文件描述符1000进行写入操作。通过循环写入8个空行，这个8就是我们要定义的后台并发的线程数。
# 为什么是写空行而不是写其它字符？因为管道文件的读取，是以行为单位的
for ((i=1; i<=processesNum; i++))
do
    echo >&1000
done

# 此处设置合适的条件，否则会导致死循环
while true
do
    # read -u1000的作用就是读取管道中的一行，在这里就是读取一个空行；每次读取管道就会减少一个空行
    # 注意到结尾的&吗？它表示进程放到linux后台中执行
    read -u1000
    {
        # 执行的内容放这里
        # 执行完后台任务之后，往文件描述符1000中写入一个空行。
        # 这是关键所在了，由于read -u1000每次操作，都会导致管道减少一个空行，
        # 当linux后台放入了N个任务之后，由于文件描述符1000没有可读取的空行，将导致read -u1000一直处于等待。
        echo >&1000
    } &
    sleep 0.1 # 按实际情况设置等待时间
done

# 等待进程执行结束
wait
# 运行结束时间
echo `date +%Y-%m-%d\ %H:%M:%S` >> logs/data.log
echo "done!!!!!!!!!!"
