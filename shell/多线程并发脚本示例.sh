#!/bin/bash
# -----------------------------

tempfifo=$$.fifo                # $$表示当前执行文件的PID
begin_date=2015-12-01           # 开始时间
processesNum=10

# -----------------------------
function main(){
    sleep 0.01
    echo $begin_date
    sleep $(($RANDOM%11))   
}

# -----------------------------

# -----------------------------
# 表示在脚本运行过程中，如果接收到Ctrl+C中断命令，则关闭文件描述符1000的读写，并正常退出
# exec 1000>&-;表示关闭文件描述符1000的写
# exec 1000<&-;表示关闭文件描述符1000的读
# trap是捕获中断命令
trap "exec 1000>&-;exec 1000<&-;exit 0" 2

# 创建一个管道文件
mkfifo $tempfifo

# 将文件描述符1000与FIFO进行绑定，<读的绑定，>写的绑定，<>则标识对文件描述符1000的所有操作等同于对管道文件$tempfifo的操作
# 管道的一个重要特性，就是读写必须同时存在，缺失某一个操作，另一个操作就是滞留，而第28行的绑定文件描述符（读、写绑定）正好解决了这个问题
exec 1000<>$tempfifo
rm -rf $tempfifo

# 对文件描述符1000进行写入操作。通过循环写入8个空行，这个8就是我们要定义的后台并发的线程数。为什么是写空行而不是写其它字符？因为管道文件的读取，是以行为单位的
for ((i=1; i<=processesNum; i++))
do
    echo >&1000
done

while true
do
    # read -u1000的作用就是读取管道中的一行，在这里就是读取一个空行；每次读取管道就会减少一个空行
    # 注意到结尾的&吗？它表示进程放到linux后台中执行
    read -u1000
    {
        main
        # 执行完后台任务之后，往文件描述符1000中写入一个空行。
        # 这是关键所在了，由于read -u1000每次操作，都会导致管道减少一个空行，
        # 当linux后台放入了8个任务之后，由于文件描述符1000没有可读取的空行，将导致read -u1000一直处于等待。
        echo >&1000
    } &

    begin_date=`date -d "+1 day $begin_date" +"%Y-%m-%d"`
done

# 等待进程执行结束
wait
echo "done!!!!!!!!!!"